I"†<h1 id="my-opencode-setup-agents-commands-and-skills">My OpenCode Setup: Agents, Commands, and Skills</h1>

<p>Ever wonder what happens when you get tired of repeating the same AI prompts? You build your own personal army of specialized agents. Thatâ€™s exactly what I did with my OpenCode configuration.</p>

<h2 id="the-three-amigos-my-agent-collection">The Three Amigos: My Agent Collection</h2>

<p>Iâ€™ve got three main agents doing the heavy lifting, each with their own personality and purpose.</p>

<p><strong>The Debug Agent</strong> is my systematic detective. This guy follows a strict four-phase process: root cause investigation, pattern analysis, hypothesis testing, and implementation. No shortcuts allowed. It tracks fix attempts and stops after three failures to question whether weâ€™re solving the wrong problem. The iron law? No fixes without root cause investigation first.</p>

<p><strong>The Plan Agent</strong> is my read-only strategist. It canâ€™t touch any filesâ€”just thinks, analyzes, and delegates to explore agents. It breaks down planning into understanding the idea, exploring approaches (usually 2-3 options), and presenting designs in digestible chunks. It applies YAGNI ruthlessly and guards against overengineering.</p>

<p><strong>The Blog Writer Agent</strong> (which is writing this post) specializes in personal, informal content. It researches topics, structures posts with hooks and takeaways, and always includes sources. Temperature is cranked up to 0.7 for creativity.</p>

<h2 id="quick-commands-for-common-tasks">Quick Commands for Common Tasks</h2>

<p>Iâ€™ve got three slash commands that handle the boring stuff:</p>

<p><strong><code class="language-plaintext highlighter-rouge">/commit-all</code></strong> stages everything and creates conventional commits. It does safety checks for sensitive files and handles pre-commit hook failures gracefully.</p>

<p><strong><code class="language-plaintext highlighter-rouge">/format-then-lint</code></strong> detects available tools (npm, make, cargo, etc.) and runs formatters before linters. If anything fails, it stops and reports issues.</p>

<p><strong><code class="language-plaintext highlighter-rouge">/review</code></strong> does code reviews with programming principles in mind. It can review uncommitted changes, specific commits, branches, or even pull requests. It focuses on bugs first, then structure and performance.</p>

<h2 id="the-skill-that-keeps-me-honest">The Skill That Keeps Me Honest</h2>

<p>The <strong>good-programming-principles</strong> skill is loaded whenever Iâ€™m designing or reviewing code. It enforces KISS, DRY, YAGNI, and SOLID principles while guarding against feature creep and overengineering. Itâ€™s not dogmaticâ€”just keeps solutions simple and scoped.</p>

<h2 id="why-this-setup-works">Why This Setup Works</h2>

<p>The global <code class="language-plaintext highlighter-rouge">AGENTS.md</code> file sets communication rules: be concise, never lie, find root causes before fixing, and minimize token usage. It mandates using exploration agents for multi-file tasks and structured tools over bash utilities.</p>

<p>What I love about this setup is how it codifies good practices. The debug agent prevents me from guessing and checking. The plan agent forces me to think before building. The review command catches issues Iâ€™d miss.</p>

<p>Itâ€™s like having a team of specialists who never get tired, never forget the process, and always apply best practices. Plus, theyâ€™re available 24/7 and donâ€™t need coffee breaks.</p>

<h2 id="sources">Sources</h2>

<ul>
  <li><a href="https://github.com/sacenox/dotfiles/tree/main/opencode">OpenCode config directory</a></li>
</ul>
:ET